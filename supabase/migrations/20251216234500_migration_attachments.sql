-- ==========================================
-- COMMUNE ATTACHMENTS MIGRATION
-- ==========================================

-- 1. Create Attachments Table
CREATE TABLE IF NOT EXISTS public.discussion_post_attachments (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    post_id UUID REFERENCES public.discussion_posts(id) ON DELETE CASCADE, -- Nullable initially to allow upload before post creation
    storage_path TEXT NOT NULL,
    file_name TEXT NOT NULL,
    mime_type TEXT,
    size_bytes BIGINT,
    type TEXT NOT NULL CHECK (type IN ('image', 'pdf', 'file')),
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    created_by UUID REFERENCES public.profiles(id)ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_post_attachments_post_id ON public.discussion_post_attachments(post_id);

-- 2. Enable RLS
ALTER TABLE public.discussion_post_attachments ENABLE ROW LEVEL SECURITY;

-- 3. RLS Policies

-- SELECT: Accessible if the user can access the parent channel
-- This relies on the chain: attachment -> post -> thread -> channel
-- If post_id is NULL (orphan/pending), only the creator can see it.
CREATE POLICY "View Attachments" ON public.discussion_post_attachments
    FOR SELECT
    USING (
        (post_id IS NOT NULL AND EXISTS (
            SELECT 1
            FROM public.discussion_posts p
            JOIN public.discussion_threads t ON t.id = p.thread_id
            JOIN public.discussion_channels c ON c.id = t.channel_id
            WHERE p.id = discussion_post_attachments.post_id
              AND public.has_channel_access(c.visibility)
        ))
        OR
        (post_id IS NULL AND auth.uid() = created_by)
    );

-- INSERT: Authenticated users can upload
CREATE POLICY "Upload Attachments" ON public.discussion_post_attachments
    FOR INSERT
    WITH CHECK (
        auth.role() = 'authenticated' AND
        auth.uid() = created_by
    );

-- UPDATE/DELETE: Only Creator or Admins
CREATE POLICY "Manage Attachments" ON public.discussion_post_attachments
    FOR ALL
    USING (
        auth.role() = 'authenticated' AND (
            created_by = auth.uid() OR
            public.get_user_role(auth.uid()) IN ('admin', 'admin_party', 'yantrik', 'central_committee', 'board')
        )
    );


-- 4. Storage Bucket Setup (Attempt to create if not exists)
INSERT INTO storage.buckets (id, name, public)
VALUES ('commune-uploads', 'commune-uploads', false)
ON CONFLICT (id) DO NOTHING;

-- 5. Storage Policies for 'commune-uploads'
-- We cannot easily join to SQL tables from storage policies in a performant way without complex functions.
-- For strict security, we will rely on Signed URLs generated by the backend for READ access.
-- For WRITE access, we allow authenticated users to upload to their own folder or generally if authenticated.
-- Since we use Signed URLs for reading, we can keep the bucket private.

-- Allow Authenticated uploads
CREATE POLICY "Authenticated Uploads" ON storage.objects
    FOR INSERT TO authenticated
    WITH CHECK ( bucket_id = 'commune-uploads' );

-- Allow Creators to Update/Delete their own files
CREATE POLICY "Creator Manage Files" ON storage.objects
    FOR ALL TO authenticated
    USING ( bucket_id = 'commune-uploads' AND owner = auth.uid() );

-- 6. Orphan Cleanup Function
CREATE OR REPLACE FUNCTION public.cleanup_orphaned_attachments()
RETURNS void AS $$
BEGIN
    -- Delete attachments where post_id is NULL and created > 24 hours ago
    DELETE FROM public.discussion_post_attachments
    WHERE post_id IS NULL
      AND created_at < now() - INTERVAL '24 hours';
      
    -- Note: This does NOT delete the actual file from Storage. 
    -- A separate trigger or edge function would be needed to sync Storage deletions.
    -- For MVP, this clears the DB metadata clutter.
END;
$$ LANGUAGE plpgsql;

-- Grant execute to postgres/service_role/authenticated (if we want to call it via RPC)
GRANT EXECUTE ON FUNCTION public.cleanup_orphaned_attachments TO authenticated;
GRANT EXECUTE ON FUNCTION public.cleanup_orphaned_attachments TO service_role;
